import traceback
from threading import Lock, Thread, Timer
from typing import Dict, Set

from disk.icmp.data_ip import IPHost
from disk.icmp.highest_availability_allocator import HighestAvailabilityAllocator
from disk.local.local_disk import LocalDisk
from fs.config import BLOCK_SIZE_BYTES, IFACE
from fs.physical_block import PhysicalBlock
from scanner.host_manager import HostManager
from pymongo import MongoClient
from scapy.all import IP, ICMP, send, sniff, Ether


class IcmpDisk(LocalDisk):
    def __init__(self, block_size_bytes=BLOCK_SIZE_BYTES):
        super().__init__(block_size_bytes)

        self._host_manager = HostManager()
        self._host_allocator = HighestAvailabilityAllocator(host_manager=self._host_manager)
        self._bdata: Dict[int, bytes] = {}
        self._host_to_bid: Dict[str, int] = {}
        self._host_to_host_group: Dict[str, Set[IPHost]] = {}
        self._host_to_timer: Dict[str, Timer] = {}
        self._bid_to_host: Dict[int, str] = {}

        self._lock = Lock()

        self.t = Thread(target=self.worker_loopback)
        self.t.daemon = True
        self.t.start()

    def worker_loopback(self):
        print("Loopback worker is running")
        def handle_icmp_packet(packet):
            if packet.haslayer(ICMP):
                try:
                    with self._lock:
                        h = packet[IP].src
                        bid = self._host_to_bid.get(h)
                        if bid is not None:
                            self.send_data_to_host(h, self._bdata[bid])
                            print(f"Looped back data to host {h}")
                        else:
                            print(f"WARNING - received packet from {h} with no bid reference")
                except:
                    traceback.print_exc()

        while True:
            try:
                sniff(filter="icmp", prn=handle_icmp_packet, iface=IFACE,
                      lfilter=lambda pkt: pkt[Ether].src != Ether().src)
            except:
                traceback.print_exc()

    def send_data_to_host(self, h: str, data, set_timer=True):
        ip_packet = IP(dst=h)
        icmp_packet = ICMP() / data
        packet = ip_packet / icmp_packet
        send(packet, iface=IFACE)
        if set_timer:
            t = self._host_to_timer.get(h)
            if t:
                t.cancel()
            self._host_to_timer[h] = Timer(1, self.send_data_to_host,args=(h, data) )
            self._host_to_timer[h].start()

        print(f"Sent payload to {h} of len {len(data)} block {self._host_to_bid[h]}")

    def read_block_by_id(self, bid: int):
        with self._lock:
            return self._bdata[bid]  # Bypass hosts for testing

    def write_block_by_id(self, bid: int, offset, data):
        with self._lock:
            self._bdata[bid] = self._bdata[bid][:offset] + data + self._bdata[bid][offset + len(data):]

    def allocate_block_storage(self, b: PhysicalBlock):
        with self._lock:
            self._bdata[b.bid] = b'\x00' * self._block_size_bytes
            hosts = self._host_allocator.allocate_hosts_group()
            for h in hosts:
                self._host_to_bid[h.addr] = b.bid
                self._host_to_host_group[h.addr] = hosts
                self._bid_to_host[b.bid] = h.addr
                try:
                    self.send_data_to_host(h.addr, self._bdata[b.bid])
                except:
                    print(len(self._bdata[b.bid]))
                    traceback.print_exc()

    def duplicate_physical_block(self, physical_block: PhysicalBlock):
        raise NotImplementedError()
