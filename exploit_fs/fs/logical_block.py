from typing import List, Set

from sortedcontainers import SortedDict

from config import BLOCK_SIZE_BYTES
from disk.base_disk import BaseDisk
from fs.logical_to_physical_block_ref import LogicalToPhysicalBlockRef

from seq import RunningSequence


class LogicalBlock(RunningSequence):
    DEFAULT_BLOCK_SIZE_BYTES = BLOCK_SIZE_BYTES

    def __init__(self, physical_block_store: BaseDisk, lid: int = None, ref_physical_block: SortedDict = None):
        if ref_physical_block is None:
            ref_physical_block = SortedDict()

        self.physical_block_store = physical_block_store

        self._lid = self.get_new_id() if lid is None else lid
        self.update_created_bid(self._lid)

        self.__ref_physical_block: SortedDict[
            int, LogicalToPhysicalBlockRef] = ref_physical_block  # {<logical_offset_end>: LogicalToPhysicalBlockRef}

    def __hash__(self) -> int:
        return hash(self.lid)

    @property
    def lid(self):
        return self._lid

    @property
    def block_size(self):
        return self.DEFAULT_BLOCK_SIZE_BYTES

    def data_hash(self):
        return hash(self.read())

    def data_hash_by_offset(self, start_offset, end_offset):
        return hash(self.read()[start_offset:end_offset])

    def set_logical_to_physical_refs(self, refs: SortedDict):
        self.__ref_physical_block = refs
        ref: LogicalToPhysicalBlockRef
        for ref in refs.values():
            self.physical_block_store.get_block_by_id(ref.physical_block_id).add_logical_block_ref(ref)

    def get_logical_to_physical_refs(self):
        return self.__ref_physical_block

    def read(self):
        physical_block_ref: LogicalToPhysicalBlockRef

        data = b''
        for _, physical_block_ref in self.__ref_physical_block.items():
            data += self.physical_block_store.read_block_by_id(physical_block_ref.physical_block_id)[
                    physical_block_ref.physical_block_start_offset:physical_block_ref.physical_block_end_offset]

        return data

    def get_physical_block_by_offset(self, offset):
        # print(self.__ref_physical_block.items())
        for logical_offset_end, ref in self.__ref_physical_block.items():
            if offset < logical_offset_end:
                return ref

    def can_write_to_logical_block_directly(self):
        ref: LogicalToPhysicalBlockRef

        handled_phys_block_ids = []
        for ref in self.__ref_physical_block.values():
            if ref.physical_block_id in handled_phys_block_ids:
                continue

            phys_block = self.physical_block_store.get_block_by_id(ref.physical_block_id)
            ret = phys_block.do_ref_offsets_overlap_other_logical_blocks(self.lid,
                                                                         self.__ref_physical_block.values())
            handled_phys_block_ids.append(ref.physical_block_id)

            if ret:
                return False

        return True

    def write(self, offset, data):
        if not self.__ref_physical_block.keys():
            raise RuntimeError("Cannot write to a logical block none physical blocks")

        d_len = len(data)

        while d_len:
            physical_block_ref: LogicalToPhysicalBlockRef = self.get_physical_block_by_offset(offset)

            if not physical_block_ref:
                raise RuntimeError(f"No physical block can support the needed offset for writing offset {offset}")

            to_write = data[:physical_block_ref.length]
            self.physical_block_store.write_block_by_id(physical_block_ref.physical_block_id,
                                                        physical_block_ref.physical_block_start_offset,
                                                        to_write)

            data = data[physical_block_ref.length:]
            offset += physical_block_ref.length
            d_len -= len(to_write)

        self.physical_block_store.write_block_by_id(self.__ref_physical_block.values()[0].physical_block_id, offset,
                                                    data)

    @property
    def physical_block_ref_count(self):
        return len(self.__ref_physical_block.keys())

    def inject_new_refs(self, new_refs) -> Set[int]:
        # TODO n^2
        if not new_refs:
            return set()

        calculated_refs: SortedDict[
            int, LogicalToPhysicalBlockRef] = SortedDict()

        new_ref: LogicalToPhysicalBlockRef
        for new_ref in new_refs:
            if new_ref.logical_block_id != self.lid:
                raise RuntimeError("Can't inject a ref not intended for this logical block")

            new_ref_len = new_ref.length
            new_ref_start_offset = new_ref.end_offset - new_ref_len

            myref: LogicalToPhysicalBlockRef

            for my_end_offset, myref in self.__ref_physical_block.items():
                if new_ref_start_offset >= my_end_offset or new_ref.end_offset <= myref.end_offset-myref.length:
                    calculated_refs[my_end_offset] = myref
                    continue

                my_ref_start_offset = myref.end_offset - myref.length
                if my_ref_start_offset < new_ref_start_offset:  # Allocate before chunk
                    before = LogicalToPhysicalBlockRef(self.lid, new_ref_start_offset, myref.physical_block_id,
                                                       physical_block_start_offset=myref.physical_block_start_offset,
                                                       physical_block_end_offset=myref.physical_block_start_offset + (
                                                                   new_ref_start_offset - my_ref_start_offset))
                    calculated_refs[new_ref_start_offset] = before


                if myref.end_offset > new_ref.end_offset:
                    after = LogicalToPhysicalBlockRef(self.lid, myref.end_offset, myref.physical_block_id,
                                                      physical_block_start_offset=myref.physical_block_end_offset - (myref.end_offset - new_ref.end_offset),
                                                      physical_block_end_offset=myref.physical_block_end_offset)

                    calculated_refs[myref.end_offset] = after

                # if myref.end_offset >= new_ref.end_offset:
                #     break
            print("====")
            print(new_ref)
            calculated_refs[new_ref.end_offset] = new_ref
        involed_block_ids = self.free_physical_refs()
        self.set_logical_to_physical_refs(calculated_refs)
        return involed_block_ids # TODO switch to actually getting a list of block ids that were changed

    def get_physical_refs_by_offset(self, new_logical_id: int, start_offset, end_offset):

        new_refs = []

        return new_refs
        ref: LogicalToPhysicalBlockRef

        for logical_end_offset, ref in self.__ref_physical_block.items():
            if start_offset >= logical_end_offset:
                continue

            logical_start_offset = logical_end_offset - ref.length

            physical_start_offset = ref.physical_block_start_offset + (start_offset - logical_start_offset)
            physical_end_offset = None

            if end_offset <= logical_end_offset:
                physical_end_offset = physical_start_offset + (end_offset - start_offset)
            else:
                physical_end_offset = ref.physical_block_end_offset

            added_offset = physical_end_offset - physical_start_offset
            # TODO check this function for correct offsets

            new_refs.append(LogicalToPhysicalBlockRef(new_logical_id, start_offset + added_offset,
                                                      physical_block_id=ref.physical_block_id,
                                                      physical_block_start_offset=physical_start_offset,
                                                      physical_block_end_offset=physical_end_offset))

            start_offset += added_offset
            if start_offset>=end_offset:
                break
        return new_refs

    def free_physical_refs(self) -> Set[int]:
        physical_blocks_ids_involved = set()

        physical_block_ref: LogicalToPhysicalBlockRef

        for _, physical_block_ref in self.__ref_physical_block.items():
            self.physical_block_store.free_ref(physical_block_ref)
            physical_blocks_ids_involved.add(physical_block_ref.physical_block_id)

        self.__ref_physical_block.clear()

        return physical_blocks_ids_involved
