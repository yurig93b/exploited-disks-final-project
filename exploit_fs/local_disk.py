import dataclasses
from typing import Dict, List, Set

from config import BLOCK_SIZE
from exploit_fs.base_disk import BaseDisk
from exploit_fs.logical_to_physical_block_ref import LogicalToPhysicalBlockRef
from exploit_fs.physical_block import PhysicalBlock
from free_block_offsets import FreeBlockOffsets


@dataclasses.dataclass
class AllocationResponseBlockOffsets:
    bid: int
    start_offset: int
    end_offset: int

    @property
    def length(self):
        return self.end_offset - self.start_offset


class LocalDisk(BaseDisk):
    LOCAL_PATH = "/Users/yurigrigorian/local_disk"

    def __init__(self, block_size_bytes=BLOCK_SIZE):
        super().__init__(block_size_bytes)
        self._blocks: Dict[int, PhysicalBlock] = {}
        self._free_block_offsets: Set[FreeBlockOffsets] = set()

    def update_free_block_offsets(self, block_id):
        offsets = self.get_block_by_id(block_id).available_offsets()
        if offsets:
            self._free_block_offsets.update(offsets)

    def get_block_by_id(self, bid: int):
        blk = self._blocks.get(bid)
        if blk is None:
            raise RuntimeError(f'Block {bid} not found')
        return blk

    def read_block_by_id(self, bid: int):
        self.get_block_by_id(bid)
        with open(f'{self.LOCAL_PATH}/{bid}', 'rb') as f:
            return f.read()

    def add_ref(self, ref: LogicalToPhysicalBlockRef):
        self.get_block_by_id(ref.physical_block_id).add_logical_block_ref(ref)

    def free_ref(self, ref: LogicalToPhysicalBlockRef):
        b = self.get_block_by_id(ref.physical_block_id)
        b.remove_logical_block_ref(ref)
        if not b.ref_count:
            pass

    def write_block_by_id(self, bid: int, offset, data):
        if len(data) > self._block_size_bytes - offset:
            raise RuntimeError("Can't write more than what block can hold")

        with open(f'{self.LOCAL_PATH}/{bid}', 'rb+') as f:
            f.seek(offset)
            f.write(data)

    def allocate_blocks_by_length(self, len_bytes) -> List[AllocationResponseBlockOffsets] :
        allocated: List[AllocationResponseBlockOffsets] = []
        while len_bytes:
            free_offset = None
            if self._free_block_offsets:
                free_offset = self._free_block_offsets.pop()
            else:
                allocated_whole_block = self.allocate_block()
                free_offset = FreeBlockOffsets(allocated_whole_block.bid, start_offset=0,
                                               end_offset=allocated_whole_block.block_size)

            bytes_allocated = 0
            if free_offset.length > len_bytes:
                new_free_offset_to_push_back = FreeBlockOffsets(bid=free_offset.bid,
                                                                start_offset=free_offset.start_offset + len_bytes,
                                                                end_offset=free_offset.end_offset)
                self._free_block_offsets.update([new_free_offset_to_push_back])
                alloc_reponse = AllocationResponseBlockOffsets(bid=free_offset.bid,
                                                               start_offset=free_offset.start_offset,
                                                               end_offset=free_offset.start_offset + len_bytes)
                allocated.append(alloc_reponse)
                bytes_allocated = len_bytes
            else:
                alloc_reponse = AllocationResponseBlockOffsets(bid=free_offset.bid,
                                                               start_offset=free_offset.start_offset,
                                                               end_offset=free_offset.end_offset)
                allocated.append(alloc_reponse)
                bytes_allocated = free_offset.length

            len_bytes -= bytes_allocated
        return allocated

    def allocate_block(self):
        b = PhysicalBlock()
        with open(f'{self.LOCAL_PATH}/{b.bid}', 'wb') as f:
            f.truncate(self._block_size_bytes)
        self._blocks[b.bid] = b

        return b

    def duplicate_physical_block(self, physical_block: PhysicalBlock):
        b = PhysicalBlock()
        with open(f'{self.LOCAL_PATH}/{physical_block.bid}', 'rb') as s:
            with open(f'{self.LOCAL_PATH}/{b.bid}', 'wb') as t:
                t.write(s.read())
        return b
