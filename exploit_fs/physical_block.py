from typing import Dict, List

from config import BLOCK_SIZE
from exploit_fs.logical_to_physical_block_ref import LogicalToPhysicalBlockRef
from exploit_fs.seq import RunningSequence
from free_block_offsets import FreeBlockOffsets


class PhysicalBlock(RunningSequence):
    DEFAULT_PHYSICAL_BLOCK_SIZE = BLOCK_SIZE

    def __init__(self, bid: int = None):
        self._bid = self.get_new_id() if bid is None else bid
        self.update_created_bid(self._bid)
        self._refs_logical_blocks: Dict[int, LogicalToPhysicalBlockRef] = {}  # {ref_id: LogicalToPhysicalBlockRef}

    def are_ref_offsets_shared_with_other_logical_blocks(self, ok_lid, my_refs: List[LogicalToPhysicalBlockRef]):
        for s_r in my_refs:
            if s_r.physical_block_id != self.bid:
                continue

            for t_r in self._refs_logical_blocks.values():
                if t_r.logical_block_id == ok_lid:
                    continue
                if t_r.physical_block_start_offset >= s_r.physical_block_end_offset and \
                        t_r.end_offset <= s_r.physical_block_start_offset:
                    continue
                return True
        return False

    def get_distinct_logical_block_references(self):
        return set([x.logical_block_id for x in self._refs_logical_blocks.values()])

    def available_offsets(self):
        KEY_START = 'S'
        KEY_END = 'E'

        to_ret = []  # [(start_off, end_off)]

        last_e = 0
        s = 0

        offsets_regions = []
        for _, ref in self._refs_logical_blocks.items():
            offsets_regions.append((ref.physical_block_start_offset, KEY_START))
            offsets_regions.append((ref.physical_block_end_offset, KEY_END))

        offsets_regions = sorted(offsets_regions)
        # print(offsets_regions)

        for off, k in offsets_regions:
            if k == KEY_END and s == 0:
                raise RuntimeError("Corrupted offsets detected")

            if k == KEY_START and s == 0:
                if off - last_e > 0:
                    to_ret.append(FreeBlockOffsets(self.bid, last_e, off))
                s += 1
            elif k == KEY_START and s > 0:
                s += 1
            elif k == KEY_END:
                s -= 1
                last_e = off

        if self.DEFAULT_PHYSICAL_BLOCK_SIZE - last_e:
            to_ret.append(FreeBlockOffsets(self.bid, last_e, self.DEFAULT_PHYSICAL_BLOCK_SIZE))
        return to_ret

    @property
    def bid(self):
        return self._bid

    @property
    def block_size(self):
        return self.DEFAULT_PHYSICAL_BLOCK_SIZE

    @property
    def ref_count(self):
        return len(self._refs_logical_blocks.keys())

    def add_logical_block_ref(self, l_to_b_ref: LogicalToPhysicalBlockRef):
        self._refs_logical_blocks[l_to_b_ref.ref_id] = l_to_b_ref

    def remove_logical_block_ref(self, l_to_b_ref: LogicalToPhysicalBlockRef):
        if l_to_b_ref.ref_id in self._refs_logical_blocks:
            del self._refs_logical_blocks[l_to_b_ref.ref_id]
